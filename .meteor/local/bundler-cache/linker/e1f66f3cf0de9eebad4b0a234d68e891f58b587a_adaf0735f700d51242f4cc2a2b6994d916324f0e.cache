[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nECMAScript = Package.ecmascript.ECMAScript;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nmeteorInstall = Package.modules.meteorInstall;\nPromise = Package.promise.Promise;\n_ = Package.underscore._;\nAutoupdate = Package.autoupdate.Autoupdate;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"server\":{\"bots.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/bots.js                                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\n// This is where you add bots, like Bob:\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {} // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n\n\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"callbacks.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/callbacks.js                                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\nlet getFullyConnectedLayer;\nmodule.link(\"./util\", {\n  getFullyConnectedLayer(v) {\n    getFullyConnectedLayer = v;\n  }\n\n}, 1);\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {\n  console.log(\"Game started\");\n  game.players.forEach(player => {\n    player.set(\"inactive\", false);\n    const network = player.get(\"neighbors\");\n    const activeChats = [];\n    network.map(otherNodeId => {\n      var pairOfPlayers = [player.get(\"nodeId\"), parseInt(otherNodeId)];\n      pairOfPlayers.sort((p1, p2) => p1 - p2);\n      const otherPlayer = game.players.find(p => p.get(\"nodeId\") === parseInt(otherNodeId)); // const otherPlayerId = otherPlayer.id;\n\n      const chatKey = \"\".concat(pairOfPlayers[0], \"-\").concat(pairOfPlayers[1]);\n      activeChats.push(chatKey);\n    }); // Default all chats to be open when game starts\n\n    player.set(\"activeChats\", activeChats);\n    console.log(player.get(\"activeChats\"));\n  });\n  game.set(\"previousNumActivePlayers\", game.players.length);\n}); // onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\n\nEmpirica.onRoundStart((game, round) => {\n  game.players.forEach(player => {\n    player.set(\"submitted\", false);\n    player.set(\"symbolSelected\", \"\");\n  });\n  round.set(\"result\", false);\n  round.set(\"numPlayersSubmitted\", 0); // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\"));\n\n  if (activePlayers.length < game.get(\"previousNumActivePlayers\")) {\n    // Someone left in the middle of the round\n    if (game.treatment.endGameIfPlayerIdle) {\n      activePlayers.forEach(p => {\n        p.exit(\"someoneInactive\");\n      });\n    } else {\n      getFullyConnectedLayer(game); // Updates the neighbors to be fully connected\n    }\n  }\n\n  game.set(\"previousNumActivePlayers\", activePlayers.length);\n  console.log(\"Round Started\");\n}); // onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\n\nEmpirica.onStageStart((game, round, stage) => {\n  console.log(\"Stage Started\"); // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\"));\n\n  if (stage.name === \"Task\") {\n    activePlayers.forEach(player => {\n      console.log(player.id);\n      console.log(\"Symbols : \".concat(player.get(\"\".concat(stage.displayName))));\n    });\n    console.log(\"Answer: \".concat(stage.get(\"answer\")));\n  }\n\n  if (stage.name === \"Survey\") {\n    activePlayers.forEach(player => {\n      player.set(\"surveyNumber\", 1);\n    });\n  } // game.players.forEach((player) => {\n  //   player.set(\"submitted\", false);\n  // });\n  // stage.set(\"showResults\", false);\n  // stage.set(\"resultsShown\", false);\n\n}); // onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\n\nEmpirica.onStageEnd((game, round, stage) => {\n  console.log(\"Stage Ended\");\n}); // onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\n\nEmpirica.onRoundEnd((game, round) => {// game.players.forEach(player => {\n  //   const value = player.round.get(\"value\") || 0;\n  //   const prevScore = player.get(\"score\") || 0;\n  //   player.set(\"score\", prevScore + value);\n  // });\n}); // onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\n\nEmpirica.onGameEnd(game => {}); // ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n//\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n//\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n// // onSet is called when the experiment code call the .set() method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // // Example filtering\n//   // if (key !== \"value\") {\n//   //   return;\n//   // }\n// });\n\nEmpirica.onSet((game, round, stage, player, // Player who made the change\ntarget, // Object on which the change was made (eg. player.set() => player)\ntargetType, // Type of object on which the change was made (eg. player.set() => \"player\")\nkey, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\nvalue, // New value\nprevValue // Previous value\n) => {\n  const players = game.players; // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\")); // Some player decides to reconsider their answer\n\n  console.log(\"key\", key);\n\n  if (key === \"submitted\") {\n    console.log(\"Updated a submission\"); // Checks if everyone has submitted their answer and if so, submit the stage\n\n    let allSubmitted = true;\n    let numPlayersSubmitted = 0;\n    activePlayers.forEach(player => {\n      if (player.get(\"submitted\")) {\n        numPlayersSubmitted += 1;\n      }\n\n      allSubmitted = player.get(\"submitted\") && allSubmitted;\n    });\n    round.set(\"numPlayersSubmitted\", numPlayersSubmitted);\n\n    if (allSubmitted) {\n      const log = stage.get(\"log\");\n      computeScore(activePlayers, stage, round); // Need to submit for submit the stage for every player\n\n      game.players.forEach(player => {\n        player.stage.submit();\n      });\n    } //   if (stage.get(\"resultsShown\")) {\n    //     players.forEach((player) => {\n    //       player.stage.submit();\n    //     })\n    //   }\n    // }\n    // if (targetType === \"stage\" && key === \"resultsShown\") {\n    //   if (stage.get(\"resultsShown\")) {\n    //     players.forEach((player) => {\n    //       player.stage.submit();\n    //     })\n    //   }\n\n  } // else if (key === \"inactive\") {\n  // getFullyConnectedLayer(game);\n  // }\n\n\n  return;\n});\n\nfunction computeScore(activePlayers, stage, round) {\n  let success = true;\n  console.log(\"CORRECT ANSWER:\");\n  console.log(stage.get(\"answer\"));\n  console.log(\"Players guessed:\");\n  activePlayers.forEach(player => {\n    const submission = player.get(\"symbolSelected\");\n    console.log(submission);\n\n    if (submission !== stage.get(\"answer\")) {\n      success = false;\n    }\n  });\n  round.set(\"result\", success);\n\n  if (success) {\n    activePlayers.forEach(player => {\n      const prevScore = player.get(\"score\") || 0;\n      player.set(\"score\", prevScore + 1);\n    });\n    console.log(\" All players got it correctly\");\n  }\n} // // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//   //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n// });\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue, // Previous value\n//   isAppend // True if the change was an append, false if it was a set\n// ) => {\n//   // `onChange` is useful to run server-side logic for any user interaction.\n//   // Note the extra isAppend boolean that will allow to differenciate sets and\n//   // appends.\n//    Game.set(\"lastChangeAt\", new Date().toString())\n// });\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit((\n//   game,\n//   round,\n//   stage,\n//   player // Player who submitted\n// ) => {\n// });\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"constants.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/constants.js                                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.export({\n  testTangrams: () => testTangrams\n});\nconst fillerNames = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\nconst allSymbols = [\"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\", \"t10\", \"t11\", \"t12\"]; // n = number of people , p = number of symbols\n// (n-1)*p + 1\n// i.e. n = 3, p = 3 : 7\n\nconst testTangrams = [{\n  _id: \"0\",\n  taskName: \"Task 1\",\n  symbols: allSymbols,\n  answer: \"t1\"\n}, {\n  _id: \"1\",\n  taskName: \"Task 2\",\n  symbols: allSymbols,\n  answer: \"t2\"\n}, {\n  _id: \"2\",\n  taskName: \"Task 3\",\n  symbols: allSymbols,\n  answer: \"t3\"\n}, {\n  _id: \"3\",\n  taskName: \"Task 4\",\n  symbols: allSymbols,\n  answer: \"t4\"\n}, {\n  _id: \"4\",\n  taskName: \"Task 5\",\n  symbols: allSymbols,\n  answer: \"t5\"\n}, {\n  _id: \"5\",\n  taskName: \"Task 6\",\n  symbols: allSymbols,\n  answer: \"t6\"\n}, {\n  _id: \"6\",\n  taskName: \"Task 7\",\n  symbols: allSymbols,\n  answer: \"t7\"\n}, {\n  _id: \"7\",\n  taskName: \"Task 8\",\n  symbols: allSymbols,\n  answer: \"t8\"\n}, {\n  _id: \"8\",\n  taskName: \"Task 9\",\n  symbols: allSymbols,\n  answer: \"t9\"\n}, {\n  _id: \"9\",\n  taskName: \"Task 10\",\n  symbols: allSymbols,\n  answer: \"t10\"\n}, {\n  _id: \"10\",\n  taskName: \"Task 11\",\n  symbols: allSymbols,\n  answer: \"t11\"\n}, {\n  _id: \"11\",\n  taskName: \"Task 12\",\n  symbols: allSymbols,\n  answer: \"t12\"\n}, {\n  _id: \"12\",\n  taskName: \"Task 13\",\n  symbols: allSymbols,\n  answer: \"t1\"\n}, {\n  _id: \"13\",\n  taskName: \"Task 14\",\n  symbols: allSymbols,\n  answer: \"t2\"\n}, {\n  _id: \"14\",\n  taskName: \"Task 15\",\n  symbols: allSymbols,\n  answer: \"t3\"\n}];\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"util.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/util.js                                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.export({\n  getNeighbors: () => getNeighbors,\n  getFullyConnectedLayer: () => getFullyConnectedLayer\n});\n\nfunction getNeighbors(structure, player) {\n  const neighbors = [];\n  let network = structure.split(\",\");\n  network.forEach(n => {\n    const connection = n.split(\"-\");\n    const playerIndex = player.get(\"nodeId\");\n\n    if (playerIndex === parseInt(connection[0])) {\n      neighbors.push(connection[1]);\n    } else if (playerIndex === parseInt(connection[1])) {\n      neighbors.push(connection[0]);\n    }\n  });\n  return _.uniq(neighbors, true);\n}\n\nfunction getFullyConnectedLayer(game) {\n  const activeNodes = [];\n  const allNodes = []; // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\")); // activePlayers.forEach((p) => {\n  //   activeNodes.push(`${p.get(\"nodeId\")}`);\n  // })\n\n  game.players.forEach(p => {\n    // if (p.online === true && !p.get(\"inactve\")) {\n    if (!p.get(\"inactve\")) {\n      activeNodes.push(\"\".concat(p.get(\"nodeId\")));\n    }\n\n    allNodes.push(\"\".concat(p.get(\"nodeId\")));\n  });\n  game.players.forEach(p => {\n    // Only show active people\n    // const newNeighbors = activeNodes.filter(id => parseInt(id) !== p.get(\"nodeId\"))\n    // p.set(\"neighbors\", newNeighbors);\n    // Show everyone, mark offline people as offline\n    const newNeighbors = allNodes.filter(id => parseInt(id) !== p.get(\"nodeId\"));\n    p.set(\"neighbors\", newNeighbors);\n    console.log(p.get(\"neighbors\"));\n  });\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"main.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/main.js                                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\nmodule.link(\"./bots.js\");\nmodule.link(\"./callbacks.js\");\nlet testSymbols, testTangrams;\nmodule.link(\"./constants\", {\n  testSymbols(v) {\n    testSymbols = v;\n  },\n\n  testTangrams(v) {\n    testTangrams = v;\n  }\n\n}, 1);\nlet getNeighbors, getFullyConnectedLayer;\nmodule.link(\"./util\", {\n  getNeighbors(v) {\n    getNeighbors = v;\n  },\n\n  getFullyConnectedLayer(v) {\n    getFullyConnectedLayer = v;\n  }\n\n}, 2);\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\nEmpirica.gameInit(game => {\n  const {\n    treatment: {\n      playerCount,\n      networkStructure,\n      numTaskRounds,\n      numSurveyRounds,\n      setSizeBasedOnPlayerCount,\n      userInactivityDuration,\n      taskDuration,\n      defaultSetSize,\n      surveyDuration,\n      resultsDuration,\n      maxNumOverlap\n    }\n  } = game;\n  const symbolSet = testTangrams;\n  const setSize = setSizeBasedOnPlayerCount ? playerCount + 1 : defaultSetSize; //TODO: can change default value in settings\n\n  const numRoundsBeforeSurvey = numTaskRounds / numSurveyRounds;\n  const colors = [\"Green\", \"Red\", \"Yellow\", \"Blue\", \"Purlpe\", \"White\", \"Black\"];\n  game.players.forEach((player, i) => {\n    player.set(\"avatar\", \"/avatars/jdenticon/\".concat(player._id));\n    player.set(\"score\", 0); // Give each player a nodeId based on their position (indexed at 1)\n\n    player.set(\"nodeId\", i + 1);\n    player.set(\"name\", player.id);\n    player.set(\"anonymousName\", colors[i]);\n  });\n\n  if (game.players.length < game.treatment.playerCount) {\n    getFullyConnectedLayer(game);\n    game.players.forEach(p => {\n      console.log(p.get(\"neighbors\"));\n    });\n  } else {\n    game.players.forEach(p => {\n      p.set(\"neighbors\", getNeighbors(networkStructure, p));\n      console.log(p.get(\"neighbors\"));\n    });\n  } // For each round, add all the symbols, randomly select a correct answer and\n  // Constraints: Must ensure that everyone has only one symbol in common\n\n\n  _.times(numTaskRounds, i => {\n    const round = game.addRound();\n    const {\n      symbols,\n      taskName,\n      answer\n    } = symbolSet[i];\n    const taskStage = round.addStage({\n      name: \"Task\",\n      displayName: taskName,\n      answer: answer,\n      durationInSeconds: taskDuration\n    });\n    taskStage.set(\"task\", symbolSet[i]);\n    getSymbolsForPlayers(symbols, answer, setSize, taskName, game, maxNumOverlap);\n    taskStage.set(\"answer\", symbolSet[i].answer);\n    const resultStage = round.addStage({\n      name: \"Result\",\n      displayName: \"Result\",\n      durationInSeconds: resultsDuration\n    });\n\n    if ((i + 1) % numRoundsBeforeSurvey === 0) {\n      // After 5 task rounds, add a survey round\n      const surveyRound = game.addRound();\n      const surveyStages = surveyRound.addStage({\n        name: \"Survey\",\n        displayName: \"Survey\",\n        durationInSeconds: surveyDuration\n      });\n    } // Question: What's the difference between setting something and\n    // adding it into add stage\n\n  }); // function getSymbolsForPlayers(symbolSet, answer, size, taskName, game) {\n  //   let symbolsWithoutAnswer = symbolSet.filter(symbol => symbol !== answer);\n  //   let shuffledSymbols = shuffle(symbolsWithoutAnswer);\n  //   // game.players.forEach((p) => {\n  //   //   // Finding a random splice of symbols without the answer (hence -2)\n  //   //   const randomIndex = Math.floor(Math.random() * (symbolsWithoutAnswer.length + size - 2));\n  //   //   let subset = shuffledSymbols.splice(randomIndex, randomIndex + size)\n  //   //   // Adding in the answer in a random spot\n  //   //   subset.splice(randomIndex % size, 0, answer);\n  //   //   p.set(`${taskName}`, subset);\n  //   // })\n  //   let symbolFreq = {}\n  //   for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n  //     const symbol = symbolsWithoutAnswer[i]\n  //     // console.log(!symbolFreq.hasOwnProperty(symbol));\n  //     if (!symbolFreq.hasOwnProperty(symbol)) {\n  //       symbolFreq[symbol] = 0\n  //     }\n  //   }\n  //   let subsetsToCreate = game.players.length;\n  //   let subsetArray = []\n  //   let subset = []\n  //   let maxFreq = 0;\n  //   let allSameFreq = true;\n  //   // console.log(subsetsToCreate);\n  //   // console.log(\"Hi\");\n  //   // console.log(symbolFreq);\n  //   while (subsetsToCreate > 0) {\n  //     if (allSameFreq) {\n  //       maxFreq += 1\n  //     }\n  //     for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n  //       const symbol = symbolsWithoutAnswer[i]\n  //       if (symbolFreq[symbol] < maxFreq && !subset.includes(symbol)) { // Add symbols to subset based on the symbol freq\n  //         symbolFreq[symbol] += 1\n  //         subset.push(symbol);\n  //         allSameFreq = false;\n  //       }\n  //       // Subset is only missing answer => add answer\n  //       // Add subset to overall array and reset \n  //       if (subset.length === size - 1) { \n  //         const randomIndex = Math.floor(Math.random() * (size- 1));\n  //         subset.splice(randomIndex, 0, answer);\n  //         subsetArray.push(subset);\n  //         console.log(subset);\n  //         subsetsToCreate -= 1;\n  //         subset = []\n  //       }\n  //     }\n  //     // Check the frequencies of the symbols\n  //     allSameFreq = Object.keys(symbolFreq).every((key) => symbolFreq[key] === maxFreq);\n  //     // console.log(\"Same freq\");\n  //     // console.log(allSameFreq);\n  //   }\n  //   let i = 0;\n  //   game.players.forEach((p) => {\n  //     p.set(`${taskName}`, subsetArray[i]);\n  //     i += 1;\n  //   })\n  // }\n\n\n  function getSymbolsForPlayers(symbolSet, answer, setSize, taskName, game, maxNumOverlap) {\n    let symbolsWithoutAnswer = symbolSet.filter(symbol => symbol !== answer);\n    symbolsWithoutAnswer = shuffle(symbolsWithoutAnswer);\n    let numPlayers = game.players.length;\n    let numOverlap = 0; // Create a dictionary to keep track of how many times symbol has been used\n\n    let symbolFreq = {};\n\n    for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n      let symbol = symbolsWithoutAnswer[i]; // console.log(!symbolFreq.hasOwnProperty(symbol));\n\n      if (!symbolFreq.hasOwnProperty(symbol)) {\n        symbolFreq[symbol] = numPlayers - 1; // Total time a symbol can be used \n      }\n    }\n\n    game.players.forEach(player => {\n      let symbolsPicked = [];\n\n      for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n        let symbol = symbolsWithoutAnswer[i];\n\n        if (symbolsPicked.length < setSize - 1) {\n          // Add symbols until setSize - 1 for answer\n          if (symbolFreq[symbol] - 1 === 0) {\n            // This symbol will overlap\n            if (numOverlap < maxNumOverlap) {\n              // Only add if less than max overlap\n              symbolsPicked.push(symbol);\n              symbolFreq[symbol] -= 1;\n              numOverlap += 1;\n            }\n          } else {\n            symbolsPicked.push(symbol);\n            symbolFreq[symbol] -= 1;\n          }\n        }\n      }\n\n      symbolsPicked.push(answer); // Add the answer\n\n      for (var symbolToRemove of symbolsPicked) {\n        if (symbolFreq[symbolToRemove] === 0) {\n          // If symbol has been picked n-1 players times, remove it from the set\n          symbolsWithoutAnswer = symbolsWithoutAnswer.filter(symbol => symbol !== symbolToRemove);\n        }\n      }\n\n      symbolsPicked = shuffle(symbolsPicked);\n      player.set(taskName, symbolsPicked);\n    });\n  } // Shuffling arrays:\n  // https://stackoverflow.com/questions/50536044/swapping-all-elements-of-an-array-except-for-first-and-last\n\n\n  function shuffle(symbolSet) {\n    for (i = symbolSet.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [symbolSet[i], symbolSet[j]] = [symbolSet[j], symbolSet[i]];\n    }\n\n    return symbolSet;\n  }\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".mjs\"\n  ]\n});\n\nvar exports = require(\"/server/main.js\");","hash":"a6bf97af5fc2f54b8a8483e79ba397f1de813c6e","servePath":"/app.js","sourceMap":{"version":3,"sources":["server/bots.js","server/callbacks.js","server/constants.js","server/util.js","server/main.js"],"names":["Empirica","module","link","default","v","bot","onStageTick","game","round","stage","secondsRemaining","getFullyConnectedLayer","onGameStart","console","log","players","forEach","player","set","network","get","activeChats","map","otherNodeId","pairOfPlayers","parseInt","sort","p1","p2","otherPlayer","find","p","chatKey","push","length","onRoundStart","activePlayers","filter","treatment","endGameIfPlayerIdle","exit","onStageStart","name","id","displayName","onStageEnd","onRoundEnd","onGameEnd","onSet","target","targetType","key","value","prevValue","allSubmitted","numPlayersSubmitted","computeScore","submit","success","submission","prevScore","export","testTangrams","fillerNames","split","allSymbols","_id","taskName","symbols","answer","getNeighbors","structure","neighbors","n","connection","playerIndex","_","uniq","activeNodes","allNodes","newNeighbors","testSymbols","gameInit","playerCount","networkStructure","numTaskRounds","numSurveyRounds","setSizeBasedOnPlayerCount","userInactivityDuration","taskDuration","defaultSetSize","surveyDuration","resultsDuration","maxNumOverlap","symbolSet","setSize","numRoundsBeforeSurvey","colors","i","times","addRound","taskStage","addStage","durationInSeconds","getSymbolsForPlayers","resultStage","surveyRound","surveyStages","symbolsWithoutAnswer","symbol","shuffle","numPlayers","numOverlap","symbolFreq","hasOwnProperty","symbolsPicked","symbolToRemove","j","Math","floor","random"],"mappings":"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","file":"/app.js","sourcesContent":["import Empirica from \"meteor/empirica:core\";\n\n// This is where you add bots, like Bob:\n\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {}\n\n  // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n});\n","import Empirica from \"meteor/empirica:core\";\n\nimport { getFullyConnectedLayer } from \"./util\";\n\n\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {\n  console.log(\"Game started\");\n  game.players.forEach((player) => {\n    player.set(\"inactive\", false);\n    const network = player.get(\"neighbors\");\n    const activeChats = [];\n    network.map(otherNodeId => {\n      var pairOfPlayers = [player.get(\"nodeId\"), parseInt(otherNodeId)];\n      pairOfPlayers.sort((p1,p2) => p1 - p2);\n      const otherPlayer = game.players.find(p => p.get(\"nodeId\") === parseInt(otherNodeId));\n      // const otherPlayerId = otherPlayer.id;\n      const chatKey = `${pairOfPlayers[0]}-${pairOfPlayers[1]}`;\n      activeChats.push(chatKey);\n    });\n    // Default all chats to be open when game starts\n    player.set(\"activeChats\", activeChats);\n    console.log(player.get(\"activeChats\"));\n  });\n  game.set(\"previousNumActivePlayers\", game.players.length);\n});\n\n// onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\nEmpirica.onRoundStart((game, round) => {\n  game.players.forEach((player) => {\n    player.set(\"submitted\", false);\n    player.set(\"symbolSelected\", \"\");\n  });\n  round.set(\"result\", false);\n  round.set(\"numPlayersSubmitted\", 0);\n  // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\"));\n\n  if (activePlayers.length < game.get(\"previousNumActivePlayers\") ) { // Someone left in the middle of the round\n    if (game.treatment.endGameIfPlayerIdle) {\n      activePlayers.forEach((p) => {\n        p.exit(\"someoneInactive\");\n      })\n    } else {\n      getFullyConnectedLayer(game); // Updates the neighbors to be fully connected\n    }\n  \n  }\n  game.set(\"previousNumActivePlayers\", activePlayers.length);\n\n  console.log(\"Round Started\");\n\n});\n\n// onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\nEmpirica.onStageStart((game, round, stage) => {\n  console.log(\"Stage Started\")\n  // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\"));\n\n  if (stage.name === \"Task\") {\n    activePlayers.forEach((player) => {\n      console.log(player.id);\n      console.log( `Symbols : ${player.get(`${stage.displayName}`)}`);\n    });\n    console.log(`Answer: ${stage.get(\"answer\")}`);\n  }\n  if (stage.name === \"Survey\") {\n    activePlayers.forEach((player) => {\n      player.set(\"surveyNumber\" , 1)\n    });\n  }\n  // game.players.forEach((player) => {\n  //   player.set(\"submitted\", false);\n  // });\n  // stage.set(\"showResults\", false);\n  // stage.set(\"resultsShown\", false);\n\n});\n\n// onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\nEmpirica.onStageEnd((game, round, stage) =>{\n  console.log(\"Stage Ended\")\n  \n});\n\n// onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\nEmpirica.onRoundEnd((game, round) => {\n  // game.players.forEach(player => {\n  //   const value = player.round.get(\"value\") || 0;\n  //   const prevScore = player.get(\"score\") || 0;\n  //   player.set(\"score\", prevScore + value);\n  // });\n\n});\n\n// onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\nEmpirica.onGameEnd(game => {});\n\n// ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n//\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n//\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n\n// // onSet is called when the experiment code call the .set() method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // // Example filtering\n//   // if (key !== \"value\") {\n//   //   return;\n//   // }\n// });\n\nEmpirica.onSet((\n  game,\n  round,\n  stage,\n  player, // Player who made the change\n  target, // Object on which the change was made (eg. player.set() => player)\n  targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n  key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n  value, // New value\n  prevValue // Previous value\n) => {\n  const players = game.players;\n  // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n  const activePlayers = game.players.filter(p => !p.get(\"inactive\"));\n\n  // Some player decides to reconsider their answer\n  console.log(\"key\", key);\n  if (key === \"submitted\") { \n    console.log(\"Updated a submission\");\n    // Checks if everyone has submitted their answer and if so, submit the stage\n    let allSubmitted = true;\n    let numPlayersSubmitted = 0;\n    activePlayers.forEach((player) => {\n      if (player.get(\"submitted\")) {\n        numPlayersSubmitted += 1;\n      }\n      allSubmitted = player.get(\"submitted\") && allSubmitted;\n    })\n    round.set(\"numPlayersSubmitted\", numPlayersSubmitted);\n    if (allSubmitted) {\n      const log = stage.get(\"log\");\n      computeScore(activePlayers, stage, round);\n      // Need to submit for submit the stage for every player\n      game.players.forEach((player) => {\n        player.stage.submit();\n      })\n    }\n  //   if (stage.get(\"resultsShown\")) {\n  //     players.forEach((player) => {\n  //       player.stage.submit();\n  //     })\n  //   }\n  // }\n\n  // if (targetType === \"stage\" && key === \"resultsShown\") {\n  //   if (stage.get(\"resultsShown\")) {\n  //     players.forEach((player) => {\n  //       player.stage.submit();\n  //     })\n  //   }\n  }\n\n  // else if (key === \"inactive\") {\n    // getFullyConnectedLayer(game);\n  // }\n\n  return;\n\n});\n\nfunction computeScore(activePlayers, stage, round) {\n  let success = true;\n  console.log(\"CORRECT ANSWER:\")\n  console.log(stage.get(\"answer\"));\n  console.log(\"Players guessed:\")\n\n  activePlayers.forEach(player => {\n    const submission = player.get(\"symbolSelected\");\n    console.log(submission);\n    if (submission !== stage.get(\"answer\")) {\n      success = false\n    }\n  })\n  round.set(\"result\", success);\n  if (success) {\n    activePlayers.forEach(player => {\n      const prevScore = player.get(\"score\") || 0;\n      player.set(\"score\", prevScore + 1);\n    })\n    console.log(\" All players got it correctly\");\n  } \n}\n\n// // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//   //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n// });\n\n\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue, // Previous value\n//   isAppend // True if the change was an append, false if it was a set\n// ) => {\n//   // `onChange` is useful to run server-side logic for any user interaction.\n//   // Note the extra isAppend boolean that will allow to differenciate sets and\n//   // appends.\n//    Game.set(\"lastChangeAt\", new Date().toString())\n// });\n\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit((\n//   game,\n//   round,\n//   stage,\n//   player // Player who submitted\n// ) => {\n// });\n","const fillerNames = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\nconst allSymbols = [\"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\",\"t8\",\"t9\",\"t10\",\"t11\",\"t12\"];\n\n// n = number of people , p = number of symbols\n// (n-1)*p + 1\n// i.e. n = 3, p = 3 : 7\n\nexport const testTangrams = [\n  {\n    _id: \"0\",\n    taskName: \"Task 1\",\n    symbols: allSymbols,\n    answer: \"t1\",\n  },\n  {\n    _id: \"1\",\n    taskName: \"Task 2\",\n    symbols: allSymbols,\n    answer: \"t2\",\n  },\n  {\n    _id: \"2\",\n    taskName: \"Task 3\",\n    symbols: allSymbols,\n    answer: \"t3\",\n  },\n  {\n    _id: \"3\",\n    taskName: \"Task 4\",\n    symbols: allSymbols,\n    answer: \"t4\",\n  },\n  {\n    _id: \"4\",\n    taskName: \"Task 5\",\n    symbols: allSymbols,\n    answer: \"t5\",\n  },\n  {\n    _id: \"5\",\n    taskName: \"Task 6\",\n    symbols: allSymbols,\n    answer: \"t6\",\n  },\n  {\n    _id: \"6\",\n    taskName: \"Task 7\",\n    symbols: allSymbols,\n    answer: \"t7\",\n  },\n  {\n    _id: \"7\",\n    taskName: \"Task 8\",\n    symbols: allSymbols,\n    answer: \"t8\",\n  },\n  {\n    _id: \"8\",\n    taskName: \"Task 9\",\n    symbols: allSymbols,\n    answer: \"t9\",\n  },\n  {\n    _id: \"9\",\n    taskName: \"Task 10\",\n    symbols: allSymbols,\n    answer: \"t10\",\n  },\n  {\n    _id: \"10\",\n    taskName: \"Task 11\",\n    symbols: allSymbols,\n    answer: \"t11\",\n  },\n  {\n    _id: \"11\",\n    taskName: \"Task 12\",\n    symbols: allSymbols,\n    answer: \"t12\",\n  },\n  {\n    _id: \"12\",\n    taskName: \"Task 13\",\n    symbols: allSymbols,\n    answer: \"t1\",\n  },\n  {\n    _id: \"13\",\n    taskName: \"Task 14\",\n    symbols: allSymbols,\n    answer: \"t2\",\n  },\n  {\n    _id: \"14\",\n    taskName: \"Task 15\",\n    symbols: allSymbols,\n    answer: \"t3\",\n  },\n\n];\n","export function getNeighbors(structure, player) {\n    const neighbors = [];\n    let network = structure.split(\",\");\n\n    network.forEach((n) => {\n      const connection = n.split(\"-\");\n      const playerIndex = player.get(\"nodeId\");\n  \n      if (playerIndex === parseInt(connection[0])) {\n        neighbors.push(connection[1]);\n      } else if (playerIndex === parseInt(connection[1])) {\n        neighbors.push(connection[0]);\n      }\n    });\n  \n    return _.uniq(neighbors, true);\n  }\n\nexport function getFullyConnectedLayer(game) {\n    const activeNodes = [];\n    const allNodes = [];\n    // const activePlayers = game.players.filter(p => p.online === true && !p.get(\"inactive\"));\n    const activePlayers = game.players.filter(p => !p.get(\"inactive\"));\n\n\n    // activePlayers.forEach((p) => {\n    //   activeNodes.push(`${p.get(\"nodeId\")}`);\n    // })\n\n    game.players.forEach((p) => {\n      // if (p.online === true && !p.get(\"inactve\")) {\n      if (!p.get(\"inactve\")) {\n\n        activeNodes.push(`${p.get(\"nodeId\")}`);\n      }\n      allNodes.push(`${p.get(\"nodeId\")}`);\n    })\n\n    game.players.forEach((p) => {\n      // Only show active people\n      // const newNeighbors = activeNodes.filter(id => parseInt(id) !== p.get(\"nodeId\"))\n      // p.set(\"neighbors\", newNeighbors);\n\n      // Show everyone, mark offline people as offline\n      const newNeighbors = allNodes.filter(id => parseInt(id) !== p.get(\"nodeId\"))\n      p.set(\"neighbors\", newNeighbors);\n      console.log(p.get(\"neighbors\"));\n    })\n}","import Empirica from \"meteor/empirica:core\";\nimport \"./bots.js\";\nimport \"./callbacks.js\";\n\nimport { testSymbols, testTangrams } from \"./constants\"; \nimport { getNeighbors, getFullyConnectedLayer } from \"./util\";\n\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\nEmpirica.gameInit(game => {\n  const {\n    treatment: {\n      playerCount,\n      networkStructure,\n      numTaskRounds,\n      numSurveyRounds,\n      setSizeBasedOnPlayerCount,\n      userInactivityDuration,\n      taskDuration,\n      defaultSetSize,\n      surveyDuration,\n      resultsDuration,\n      maxNumOverlap,\n    },\n  } = game;\n\n\n  const symbolSet = testTangrams;\n  const setSize = setSizeBasedOnPlayerCount ? playerCount + 1 : defaultSetSize; //TODO: can change default value in settings\n  const numRoundsBeforeSurvey = numTaskRounds/numSurveyRounds;\n\n  const colors = [\"Green\", \"Red\", \"Yellow\", \"Blue\", \"Purlpe\", \"White\", \"Black\"]\n\n\n  game.players.forEach((player, i) => {\n    player.set(\"avatar\", `/avatars/jdenticon/${player._id}`);\n    player.set(\"score\", 0);\n\n    // Give each player a nodeId based on their position (indexed at 1)\n    player.set(\"nodeId\", i + 1);\n    player.set(\"name\", player.id);\n    player.set(\"anonymousName\", colors[i])\n  });\n\n\n  if (game.players.length < game.treatment.playerCount) {\n    getFullyConnectedLayer(game);\n    game.players.forEach((p) => {\n      console.log(p.get(\"neighbors\"));\n    });\n  } else {\n    game.players.forEach((p) => {\n      p.set(\"neighbors\", getNeighbors(networkStructure, p));\n      console.log(p.get(\"neighbors\"));\n    });\n  }\n\n  // For each round, add all the symbols, randomly select a correct answer and\n  // Constraints: Must ensure that everyone has only one symbol in common\n  _.times( numTaskRounds, i => {\n    const round = game.addRound();\n\n    const {symbols, taskName, answer} = symbolSet[i];\n\n    const taskStage = round.addStage({\n      name: \"Task\",\n      displayName: taskName,\n      answer: answer,\n      durationInSeconds: taskDuration\n    });\n    taskStage.set(\"task\", symbolSet[i]);\n    getSymbolsForPlayers(symbols, answer, setSize, taskName, game, maxNumOverlap)\n    taskStage.set(\"answer\", symbolSet[i].answer)\n\n    const resultStage = round.addStage({\n      name: \"Result\",\n      displayName: \"Result\",\n      durationInSeconds: resultsDuration\n    });\n    \n    if ((i+1) % numRoundsBeforeSurvey === 0) { // After 5 task rounds, add a survey round\n      const surveyRound = game.addRound();\n\n      const surveyStages = surveyRound.addStage({\n        name: \"Survey\",\n        displayName: \"Survey\",\n        durationInSeconds: surveyDuration\n      })\n    }\n\n\n    // Question: What's the difference between setting something and\n    // adding it into add stage\n  });\n\n\n\n  // function getSymbolsForPlayers(symbolSet, answer, size, taskName, game) {\n  //   let symbolsWithoutAnswer = symbolSet.filter(symbol => symbol !== answer);\n  //   let shuffledSymbols = shuffle(symbolsWithoutAnswer);\n\n  //   // game.players.forEach((p) => {\n  //   //   // Finding a random splice of symbols without the answer (hence -2)\n  //   //   const randomIndex = Math.floor(Math.random() * (symbolsWithoutAnswer.length + size - 2));\n  //   //   let subset = shuffledSymbols.splice(randomIndex, randomIndex + size)\n      \n  //   //   // Adding in the answer in a random spot\n  //   //   subset.splice(randomIndex % size, 0, answer);\n  //   //   p.set(`${taskName}`, subset);\n  //   // })\n\n  //   let symbolFreq = {}\n  //   for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n  //     const symbol = symbolsWithoutAnswer[i]\n  //     // console.log(!symbolFreq.hasOwnProperty(symbol));\n  //     if (!symbolFreq.hasOwnProperty(symbol)) {\n  //       symbolFreq[symbol] = 0\n  //     }\n  //   }\n\n  //   let subsetsToCreate = game.players.length;\n  //   let subsetArray = []\n  //   let subset = []\n  //   let maxFreq = 0;\n  //   let allSameFreq = true;\n  //   // console.log(subsetsToCreate);\n  //   // console.log(\"Hi\");\n  //   // console.log(symbolFreq);\n  //   while (subsetsToCreate > 0) {\n  //     if (allSameFreq) {\n  //       maxFreq += 1\n  //     }\n  //     for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n  //       const symbol = symbolsWithoutAnswer[i]\n  //       if (symbolFreq[symbol] < maxFreq && !subset.includes(symbol)) { // Add symbols to subset based on the symbol freq\n  //         symbolFreq[symbol] += 1\n  //         subset.push(symbol);\n  //         allSameFreq = false;\n\n  //       }\n  //       // Subset is only missing answer => add answer\n  //       // Add subset to overall array and reset \n  //       if (subset.length === size - 1) { \n  //         const randomIndex = Math.floor(Math.random() * (size- 1));\n  //         subset.splice(randomIndex, 0, answer);\n  //         subsetArray.push(subset);\n  //         console.log(subset);\n  //         subsetsToCreate -= 1;\n  //         subset = []\n  //       }\n  //     }\n  //     // Check the frequencies of the symbols\n  //     allSameFreq = Object.keys(symbolFreq).every((key) => symbolFreq[key] === maxFreq);\n  //     // console.log(\"Same freq\");\n  //     // console.log(allSameFreq);\n  //   }\n  //   let i = 0;\n  //   game.players.forEach((p) => {\n  //     p.set(`${taskName}`, subsetArray[i]);\n  //     i += 1;\n  //   })\n\n  // }\n\n  function getSymbolsForPlayers(symbolSet, answer, setSize, taskName, game, maxNumOverlap) {\n      let symbolsWithoutAnswer = symbolSet.filter(symbol => symbol !== answer);\n      symbolsWithoutAnswer = shuffle(symbolsWithoutAnswer);\n      let numPlayers = game.players.length;\n      let numOverlap = 0;\n\n\n      // Create a dictionary to keep track of how many times symbol has been used\n      let symbolFreq = {}\n      for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n        let symbol = symbolsWithoutAnswer[i]\n        // console.log(!symbolFreq.hasOwnProperty(symbol));\n        if (!symbolFreq.hasOwnProperty(symbol)) {\n          symbolFreq[symbol] = numPlayers - 1; // Total time a symbol can be used \n        }\n      }\n\n      game.players.forEach((player) => {\n        let symbolsPicked = [];\n        for (let i = 0; i < symbolsWithoutAnswer.length; i++) {\n          let symbol = symbolsWithoutAnswer[i]\n          if (symbolsPicked.length < setSize - 1) { // Add symbols until setSize - 1 for answer\n            if (symbolFreq[symbol] - 1 === 0) { // This symbol will overlap\n                if (numOverlap < maxNumOverlap ) { // Only add if less than max overlap\n                  symbolsPicked.push(symbol);\n                  symbolFreq[symbol] -= 1;\n                  numOverlap += 1\n                }\n            } else {\n              symbolsPicked.push(symbol);\n              symbolFreq[symbol] -= 1;\n            }\n          }\n        }\n        symbolsPicked.push(answer); // Add the answer\n        for (var symbolToRemove of symbolsPicked) {\n          if (symbolFreq[symbolToRemove] === 0) { // If symbol has been picked n-1 players times, remove it from the set\n            symbolsWithoutAnswer = symbolsWithoutAnswer.filter(symbol => symbol !== symbolToRemove);\n\n          }\n        }\n\n        symbolsPicked = shuffle(symbolsPicked);\n\n        player.set(taskName, symbolsPicked);\n      })\n\n\n  }\n\n  // Shuffling arrays:\n  // https://stackoverflow.com/questions/50536044/swapping-all-elements-of-an-array-except-for-first-and-last\n  function shuffle(symbolSet) {\n    for (i = symbolSet.length -1 ; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n\n      [symbolSet[i], symbolSet[j]] = [symbolSet[j], symbolSet[i]];\n    }\n    return symbolSet;\n  }\n\n});\n"]}}]