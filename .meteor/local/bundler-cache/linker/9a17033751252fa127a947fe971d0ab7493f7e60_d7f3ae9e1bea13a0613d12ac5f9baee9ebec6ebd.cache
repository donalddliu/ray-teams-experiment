[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nECMAScript = Package.ecmascript.ECMAScript;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nmeteorInstall = Package.modules.meteorInstall;\nPromise = Package.promise.Promise;\n_ = Package.underscore._;\nAutoupdate = Package.autoupdate.Autoupdate;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"server\":{\"bots.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/bots.js                                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\n// This is where you add bots, like Bob:\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {} // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n\n\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"callbacks.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/callbacks.js                                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {\n  console.log(\"Game started\");\n}); // onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\n\nEmpirica.onRoundStart((game, round) => {}); // onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\n\nEmpirica.onStageStart((game, round, stage) => {\n  game.players.forEach(player => {\n    player.set(\"submitted\", false);\n  });\n}); // onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\n\nEmpirica.onStageEnd((game, round, stage) => {\n  let success = true;\n  game.players.forEach(player => {\n    const answer = player.get(\"symbolSelected\");\n    console.log(answer);\n    console.log(stage.get(\"answer\"));\n\n    if (answer !== stage.get(\"answer\")) {\n      success = false;\n    }\n  });\n\n  if (success) {\n    game.players.forEach(player => {\n      const prevScore = player.get(\"score\") || 0;\n      player.set(\"score\", prevScore + 1);\n    });\n    console.log(\" All players got it correctly\");\n  }\n\n  console.log(\"Stage Ended\");\n  console.log(success);\n}); // onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\n\nEmpirica.onRoundEnd((game, round) => {// game.players.forEach(player => {\n  //   const value = player.round.get(\"value\") || 0;\n  //   const prevScore = player.get(\"score\") || 0;\n  //   player.set(\"score\", prevScore + value);\n  // });\n}); // onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\n\nEmpirica.onGameEnd(game => {}); // ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n//\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n//\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n// // onSet is called when the experiment code call the .set() method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // // Example filtering\n//   // if (key !== \"value\") {\n//   //   return;\n//   // }\n// });\n\nEmpirica.onSet((game, round, stage, player, // Player who made the change\ntarget, // Object on which the change was made (eg. player.set() => player)\ntargetType, // Type of object on which the change was made (eg. player.set() => \"player\")\nkey, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\nvalue, // New value\nprevValue // Previous value\n) => {\n  const players = game.players; // Some player decides to reconsider their answer\n\n  console.log(\"key\", key);\n\n  if (key === \"submitted\") {\n    console.log(\"Updated a submission\"); // Checks if everyone has submitted their answer and if so, submit the stage\n\n    let allSubmitted = true;\n    players.forEach(player => {\n      allSubmitted = player.get(\"submitted\") && allSubmitted;\n    });\n\n    if (allSubmitted) {\n      const log = stage.get(\"log\");\n      stage.set(\"eventLog\", log);\n      players.forEach(player => {\n        player.stage.submit();\n      });\n    }\n  }\n\n  return;\n}); // // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//   //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n// });\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue, // Previous value\n//   isAppend // True if the change was an append, false if it was a set\n// ) => {\n//   // `onChange` is useful to run server-side logic for any user interaction.\n//   // Note the extra isAppend boolean that will allow to differenciate sets and\n//   // appends.\n//    Game.set(\"lastChangeAt\", new Date().toString())\n// });\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit((\n//   game,\n//   round,\n//   stage,\n//   player // Player who submitted\n// ) => {\n// });\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"constants.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/constants.js                                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.export({\n  testSymbols: () => testSymbols\n});\nconst fillerNames = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\"); // n = number of people , p = number of symbols\n// (n-1)*p + 1\n\nconst testSymbols = [{\n  _id: \"0\",\n  taskName: \"Easy 1\",\n  symbols: [\"A\", \"B\", \"C\"],\n  answer: \"C\"\n}, {\n  _id: \"1\",\n  taskName: \"Easy 2\",\n  symbols: [\"D\", \"E\", \"F\"],\n  answer: \"D\"\n}, {\n  _id: \"2\",\n  taskName: \"Easy 1\",\n  symbols: [\"A\", \"B\", \"C\"],\n  answer: \"C\"\n}, {\n  _id: \"3\",\n  taskName: \"Easy 1\",\n  symbols: [\"A\", \"B\", \"C\"],\n  answer: \"C\"\n}, {\n  _id: \"4\",\n  taskName: \"Easy 1\",\n  symbols: [\"A\", \"B\", \"C\"],\n  answer: \"C\"\n}, {\n  _id: \"5\",\n  taskName: \"Easy 1\",\n  symbols: [\"A\", \"B\", \"C\"],\n  answer: \"C\"\n}, {\n  _id: \"6\",\n  taskName: \"Easy 1\",\n  symbols: [\"A\", \"B\", \"C\"],\n  answer: \"C\"\n}];\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"main.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// server/main.js                                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\nmodule.link(\"./bots.js\");\nmodule.link(\"./callbacks.js\");\nlet testSymbols;\nmodule.link(\"./constants\", {\n  testSymbols(v) {\n    testSymbols = v;\n  }\n\n}, 1);\nlet getNeighbors;\nmodule.link(\".\", {\n  getNeighbors(v) {\n    getNeighbors = v;\n  }\n\n}, 2);\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\nEmpirica.gameInit(game => {\n  const {\n    treatment: {\n      playerCount,\n      networkStructure\n    }\n  } = game;\n  game.players.forEach((player, i) => {\n    player.set(\"avatar\", \"/avatars/jdenticon/\".concat(player._id));\n    player.set(\"score\", 0); // Give each player a nodeId based on their position (indexed at 1)\n\n    player.set(\"nodeId\", i + 1);\n  });\n\n  if (playerCount > 1) {\n    check(!networkStructure, \"networkStructure must be set if in multi player!\");\n    game.players.forEach(p => {\n      p.set(\"neighbors\", getNeighbors(networkStructure, p));\n      console.log(p.get(\"neighbors\"));\n    });\n  } // For each round, add all the symbols, randomly select a correct answer and\n  // Constraints: Must ensure that everyone has only one symbol in common\n\n\n  const round = game.addRound();\n\n  _.times(testSymbols.length, i => {\n    const stage = round.addStage({\n      name: i.toString(),\n      displayName: testSymbols[i].taskName,\n      answer: testSymbols[i].answer,\n      durationInSeconds: 300\n    });\n    stage.set(\"task\", testSymbols[i]);\n    stage.set(\"answer\", testSymbols[i].answer); // Question: What's the difference between setting something and\n    // adding it into add stage\n  });\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".mjs\"\n  ]\n});\n\nvar exports = require(\"/server/main.js\");","hash":"680934c69ec78c6b0c2fc345307f0b998dd94b66","servePath":"/app.js","sourceMap":{"version":3,"sources":["server/bots.js","server/callbacks.js","server/constants.js","server/main.js"],"names":["Empirica","module","link","default","v","bot","onStageTick","game","round","stage","secondsRemaining","onGameStart","console","log","onRoundStart","onStageStart","players","forEach","player","set","onStageEnd","success","answer","get","prevScore","onRoundEnd","onGameEnd","onSet","target","targetType","key","value","prevValue","allSubmitted","submit","export","testSymbols","fillerNames","split","_id","taskName","symbols","getNeighbors","gameInit","treatment","playerCount","networkStructure","i","check","p","addRound","_","times","length","addStage","name","toString","displayName","durationInSeconds"],"mappings":"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","file":"/app.js","sourcesContent":["import Empirica from \"meteor/empirica:core\";\n\n// This is where you add bots, like Bob:\n\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {}\n\n  // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n});\n","import Empirica from \"meteor/empirica:core\";\n\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {\n  console.log(\"Game started\");\n});\n\n// onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\nEmpirica.onRoundStart((game, round) => {});\n\n// onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\nEmpirica.onStageStart((game, round, stage) => {\n  game.players.forEach((player) => {\n    player.set(\"submitted\", false);\n  });\n\n});\n\n// onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\nEmpirica.onStageEnd((game, round, stage) => {\n  let success = true;\n  game.players.forEach(player => {\n    const answer = player.get(\"symbolSelected\");\n    console.log(answer);\n    console.log(stage.get(\"answer\"));\n    if (answer !== stage.get(\"answer\")) {\n      success = false\n    }\n  })\n  if (success) {\n    game.players.forEach(player => {\n      const prevScore = player.get(\"score\") || 0;\n      player.set(\"score\", prevScore + 1);\n    })\n    console.log(\" All players got it correctly\");\n  } \n  console.log(\"Stage Ended\")\n  console.log(success);\n});\n\n// onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\nEmpirica.onRoundEnd((game, round) => {\n  // game.players.forEach(player => {\n  //   const value = player.round.get(\"value\") || 0;\n  //   const prevScore = player.get(\"score\") || 0;\n  //   player.set(\"score\", prevScore + value);\n  // });\n\n});\n\n// onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\nEmpirica.onGameEnd(game => {});\n\n// ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n//\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n//\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n\n// // onSet is called when the experiment code call the .set() method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // // Example filtering\n//   // if (key !== \"value\") {\n//   //   return;\n//   // }\n// });\n\nEmpirica.onSet((\n  game,\n  round,\n  stage,\n  player, // Player who made the change\n  target, // Object on which the change was made (eg. player.set() => player)\n  targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n  key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n  value, // New value\n  prevValue // Previous value\n) => {\n  const players = game.players;\n  // Some player decides to reconsider their answer\n  console.log(\"key\", key);\n  if (key === \"submitted\") { \n    console.log(\"Updated a submission\");\n    // Checks if everyone has submitted their answer and if so, submit the stage\n    let allSubmitted = true;\n    players.forEach((player) => {\n      allSubmitted = player.get(\"submitted\") && allSubmitted;\n    })\n    if (allSubmitted) {\n      const log = stage.get(\"log\");\n      stage.set(\"eventLog\", log);\n\n\n      players.forEach((player) => {\n        player.stage.submit();\n      })\n    }\n  }\n  return;\n\n});\n\n// // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//   //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n// });\n\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue, // Previous value\n//   isAppend // True if the change was an append, false if it was a set\n// ) => {\n//   // `onChange` is useful to run server-side logic for any user interaction.\n//   // Note the extra isAppend boolean that will allow to differenciate sets and\n//   // appends.\n//    Game.set(\"lastChangeAt\", new Date().toString())\n// });\n\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit((\n//   game,\n//   round,\n//   stage,\n//   player // Player who submitted\n// ) => {\n// });\n","const fillerNames = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\n\n// n = number of people , p = number of symbols\n// (n-1)*p + 1\nexport const testSymbols = [\n  {\n    _id: \"0\",\n    taskName: \"Easy 1\",\n    symbols: [\"A\", \"B\", \"C\"],\n    answer: \"C\",\n  },\n  {\n    _id: \"1\",\n    taskName: \"Easy 2\",\n    symbols: [\"D\", \"E\", \"F\"],\n    answer: \"D\",\n  },\n  {\n    _id: \"2\",\n    taskName: \"Easy 1\",\n    symbols: [\"A\", \"B\", \"C\"],\n    answer: \"C\",\n  },\n  {\n    _id: \"3\",\n    taskName: \"Easy 1\",\n    symbols: [\"A\", \"B\", \"C\"],\n    answer: \"C\",\n  },\n  {\n    _id: \"4\",\n    taskName: \"Easy 1\",\n    symbols: [\"A\", \"B\", \"C\"],\n    answer: \"C\",\n  },\n  {\n    _id: \"5\",\n    taskName: \"Easy 1\",\n    symbols: [\"A\", \"B\", \"C\"],\n    answer: \"C\",\n  },\n  {\n    _id: \"6\",\n    taskName: \"Easy 1\",\n    symbols: [\"A\", \"B\", \"C\"],\n    answer: \"C\",\n  },\n\n];","import Empirica from \"meteor/empirica:core\";\nimport \"./bots.js\";\nimport \"./callbacks.js\";\n\nimport { testSymbols } from \"./constants\"; \nimport { getNeighbors } from \".\"\n\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\nEmpirica.gameInit(game => {\n  const {\n    treatment: {\n      playerCount,\n      networkStructure,\n    },\n  } = game;\n\n\n\n  game.players.forEach((player, i) => {\n    player.set(\"avatar\", `/avatars/jdenticon/${player._id}`);\n    player.set(\"score\", 0);\n\n    // Give each player a nodeId based on their position (indexed at 1)\n    player.set(\"nodeId\", i + 1);\n  });\n\n  if (playerCount > 1) {\n    check(\n      !networkStructure,\n      \"networkStructure must be set if in multi player!\"\n    );\n\n    game.players.forEach((p) => {\n      p.set(\"neighbors\", getNeighbors(networkStructure, p));\n      console.log(p.get(\"neighbors\"));\n    });\n  }\n\n\n  // For each round, add all the symbols, randomly select a correct answer and\n  // Constraints: Must ensure that everyone has only one symbol in common\n  const round = game.addRound();\n  _.times( testSymbols.length, i => {\n    const stage = round.addStage({\n      name: i.toString(),\n      displayName: testSymbols[i].taskName,\n      answer: testSymbols[i].answer,\n      durationInSeconds: 300\n    });\n    stage.set(\"task\", testSymbols[i]);\n    stage.set(\"answer\", testSymbols[i].answer)\n\n    // Question: What's the difference between setting something and\n    // adding it into add stage\n  });\n});\n"]}}]