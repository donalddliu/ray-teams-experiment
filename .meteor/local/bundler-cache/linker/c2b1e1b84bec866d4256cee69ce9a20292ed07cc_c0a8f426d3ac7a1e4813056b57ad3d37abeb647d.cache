[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nECMAScript = Package.ecmascript.ECMAScript;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nmeteorInstall = Package.modules.meteorInstall;\nPromise = Package.promise.Promise;\n_ = Package.underscore._;\nAutoupdate = Package.autoupdate.Autoupdate;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"server\":{\"bots.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// server/bots.js                                                                                                 //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\n// This is where you add bots, like Bob:\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {} // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n\n\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"callbacks.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// server/callbacks.js                                                                                            //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {}); // onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\n\nEmpirica.onRoundStart((game, round) => {}); // onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\n\nEmpirica.onStageStart((game, round, stage) => {}); // onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\n\nEmpirica.onStageEnd((game, round, stage) => {}); // onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\n\nEmpirica.onRoundEnd((game, round) => {\n  game.players.forEach(player => {\n    const value = player.round.get(\"value\") || 0;\n    const prevScore = player.get(\"score\") || 0;\n    player.set(\"score\", prevScore + value);\n  });\n}); // onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\n\nEmpirica.onGameEnd(game => {}); // ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n//\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n//\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n// // onSet is called when the experiment code call the .set() method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // // Example filtering\n//   // if (key !== \"value\") {\n//   //   return;\n//   // }\n// });\n// // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//   //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n// });\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue, // Previous value\n//   isAppend // True if the change was an append, false if it was a set\n// ) => {\n//   // `onChange` is useful to run server-side logic for any user interaction.\n//   // Note the extra isAppend boolean that will allow to differenciate sets and\n//   // appends.\n//    Game.set(\"lastChangeAt\", new Date().toString())\n// });\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit((\n//   game,\n//   round,\n//   stage,\n//   player // Player who submitted\n// ) => {\n// });\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"main.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// server/main.js                                                                                                 //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\nmodule.link(\"./bots.js\");\nmodule.link(\"./callbacks.js\");\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\nEmpirica.gameInit(game => {\n  game.players.forEach((player, i) => {\n    player.set(\"avatar\", \"/avatars/jdenticon/\".concat(player._id));\n    player.set(\"score\", 0);\n  });\n\n  _.times(10, i => {\n    const round = game.addRound();\n    round.addStage({\n      name: \"response\",\n      displayName: \"Response\",\n      durationInSeconds: 120\n    });\n  });\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".mjs\"\n  ]\n});\n\nvar exports = require(\"/server/main.js\");","hash":"38b4877f794a1ca2e546e1dadc495f831e6b5445","servePath":"/app.js","sourceMap":{"version":3,"sources":["server/bots.js","server/callbacks.js","server/main.js"],"names":["Empirica","module","link","default","v","bot","onStageTick","game","round","stage","secondsRemaining","onGameStart","onRoundStart","onStageStart","onStageEnd","onRoundEnd","players","forEach","player","value","get","prevScore","set","onGameEnd","gameInit","i","_id","_","times","addRound","addStage","name","displayName","durationInSeconds"],"mappings":"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","file":"/app.js","sourcesContent":["import Empirica from \"meteor/empirica:core\";\n\n// This is where you add bots, like Bob:\n\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {}\n\n  // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n});\n","import Empirica from \"meteor/empirica:core\";\n\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {});\n\n// onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\nEmpirica.onRoundStart((game, round) => {});\n\n// onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\nEmpirica.onStageStart((game, round, stage) => {});\n\n// onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\nEmpirica.onStageEnd((game, round, stage) => {});\n\n// onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\nEmpirica.onRoundEnd((game, round) => {\n  game.players.forEach(player => {\n    const value = player.round.get(\"value\") || 0;\n    const prevScore = player.get(\"score\") || 0;\n    player.set(\"score\", prevScore + value);\n  });\n});\n\n// onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\nEmpirica.onGameEnd(game => {});\n\n// ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n//\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n//\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n\n// // onSet is called when the experiment code call the .set() method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // // Example filtering\n//   // if (key !== \"value\") {\n//   //   return;\n//   // }\n// });\n\n// // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue // Previous value\n// ) => {\n//   // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//   //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n// });\n\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange((\n//   game,\n//   round,\n//   stage,\n//   player, // Player who made the change\n//   target, // Object on which the change was made (eg. player.set() => player)\n//   targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//   key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//   value, // New value\n//   prevValue, // Previous value\n//   isAppend // True if the change was an append, false if it was a set\n// ) => {\n//   // `onChange` is useful to run server-side logic for any user interaction.\n//   // Note the extra isAppend boolean that will allow to differenciate sets and\n//   // appends.\n//    Game.set(\"lastChangeAt\", new Date().toString())\n// });\n\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit((\n//   game,\n//   round,\n//   stage,\n//   player // Player who submitted\n// ) => {\n// });\n","import Empirica from \"meteor/empirica:core\";\nimport \"./bots.js\";\nimport \"./callbacks.js\";\n\n\n\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\nEmpirica.gameInit(game => {\n  game.players.forEach((player, i) => {\n    player.set(\"avatar\", `/avatars/jdenticon/${player._id}`);\n    player.set(\"score\", 0);\n  });\n\n  _.times(10, i => {\n    const round = game.addRound();\n    round.addStage({\n      name: \"response\",\n      displayName: \"Response\",\n      durationInSeconds: 120\n    });\n  });\n});\n"]}}]